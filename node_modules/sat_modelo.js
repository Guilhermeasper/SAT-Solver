/**
 * This file should be placed at the node_modules sub-directory of the directory where you're 
 * executing it.
 * 
 * Written by Guilherme Afonso and João V. Valadares in November/2018. 
 */

// Exports a function that receive a .cnf file, extract his formula from and then test
// if the problem have a satisfying assignment, if so return true and the assignment
exports.solve = function (fileName) {
	let formula = readFormula(fileName)
	let result = doSolve(formula.clauses, formula.variables) // 
	return result // two fields: isSat and satisfyingAssignment
}

function readFormula(fileName) {
	// To read the file, it is possible to use the 'fs' module. 
	// Use function readFileSync and not readFile. 
	// First read the lines of text of the file and only afterward use the auxiliary functions.
	var fs = require('fs')
	let text = fs.readFileSync(fileName, 'utf-8').split("\n") //  an array containing lines of text extracted from the file.
	let clauses = readClauses(text)
	let variables = readVariables(clauses)

	// In the following line, text is passed as an argument so that the function
	// is able to extract the problem specification.
	let specOk = checkProblemSpecification(text, clauses, variables)

	let result = {
		'clauses': [],
		'variables': []
	}
	if (specOk) {
		result.clauses = clauses
		result.variables = variables
	}
	return result
}

function readClauses(text) {
	let clauses = []
	let aux = []
	let lines = ""

	for (let i = 0; i < text.length; i++) {
		if (text[i].charAt(0) != 'c' && text[i].charAt(0) != 'p' && text[i].charAt(0) != '\r') {
			lines += " " + text[i]
		}
	}

	lines = lines.split(" ")

	for (let i = 0; i < lines.length; i++) {
		if (lines[i].charAt(0) != "" && lines[i].charAt(0) != '0') {
			aux.push(lines[i])
		}
		if (lines[i].charAt(0) == '0' && aux.length > 0) {
			clauses.push(aux)
			aux = []
		}
	}
	return clauses
}

function readVariables(clauses) {
	let variables = []
	let biggestValue = 0

	for (let i = 0; i < clauses.length; i++) {
		for (let j = 0; j < clauses[i].length; j++) {
			if (Math.abs(clauses[i][j] > biggestValue)) {
				biggestValue = Math.abs(clauses[i][j])
			}
		}
	}

	for (let i = 0; i < biggestValue; i++) {
		variables.push(false)
	}
	return variables
}

function checkProblemSpecification(text, clauses, variables) {
	let clausesLength
	let variablesLength
	let noSpecification = true

	for (let i = 0; i < text.length; i++) {
		let lineText = text[i]
		if (lineText.charAt(0) == 'p') {
			noSpecification = false
			variablesLength = lineText.split(" ")[2]
			clausesLength = lineText.split(" ")[3]
		}
	}

	if ((variables.length == variablesLength && clauses.length == clausesLength) || noSpecification) {
		return true
	} else {
		return false
	}
}


// Checks whether the assignment satisfies the clause or not
function doSolve(clauses, assignment) {
	let isSat = false
	let last = Math.pow(2, assignment.length)
	let counter = 0;
	let end = Math.pow(2, assignment.length)
	while ((!isSat) && last > 0) {
		/* //Shows the progress of the program and in which assignment is it, uncomment for use
		console.log("Analisando atribuição "+assignment.toString().replace(/,/g," ")+"\n"+(counter)+" de "+end)
		counter++
		*/
		let thisClause = true
		for (i = 0; i < clauses.length && thisClause; i++) {
			let clauseSat = false
			for (j = 0; j < clauses[i].length && !clauseSat; j++) {
				// Get the index of the current assignment for the current variable
				let index = Math.abs(clauses[i][j]) - 1
				// Checks if the current variable is denied
				if (parseInt(clauses[i][j]) < 0) {
					// If the variable is denied check if the current assignment is false
					if (!assignment[index]) {
						// If so the clause is true
						clauseSat = true
					}
				} else {
					// If the variable is not denied check if the current assignment is true
					if (assignment[index]) {
						// If so the clause is true
						clauseSat = true
					}
				}
			}
			// If the current clause is false, stop checking the current assignment
			if (!clauseSat) {
				thisClause = false
			}
		}
		// If thisClause is true, means all clauses are true for the current assignment
		if (thisClause) {
			isSat = true
			// if it isn't get the next assignment for check
		} else {
			assignment = nextAssignment(assignment)
			last = last - 1
		}
	}
	let result = {
		'isSat': isSat,
		satisfyingAssignment: null
	}
	if (isSat) {
		result.satisfyingAssignment = assignment
	}
	return result
}

// Receives the current assignment and produces the next one
function nextAssignment(currentAssignment) {
	let stop = false
	for (i = currentAssignment.length - 1; i >= 0 && !stop; i--) {
		// Verify if the last variable of the assignment is false,
		// if it is, change the value to true and stop the loop
		if (!currentAssignment[i]) {
			currentAssignment[i] = true
			stop = true
			// if it isn't, change the value to false and go to the previous variable
		} else {
			currentAssignment[i] = false
		}
	}
	newAssignment = currentAssignment
	return newAssignment
}